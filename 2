import copy
import sys
A = []
B = []


# Нахождение минора
def minor(A, i, j):
    min = copy.deepcopy(A)
    for l in range(len(min)):
        del(min[l][j])
    del(min[i])
    return min

# Превращение минора в алегбраическое дополнение
def betterminor(A, i, j):
    min = minor(A, i, j)
    bettermin = determinant(min)*((-1)**(i+j))
    return bettermin

# Транспонирование маттрицы
def transpose(A):
    for i in range(len(A)):
        for j in range(i, len(A)):
            A[i][j], A[j][i] = A[j][i], A[i][j]
    return A

# Нахождение детерминанта
def determinant(A):
    if len(A) == 1:
        return A[0][0]
    else:
        det = 0
        for l in range(len(A)):
            det += A[0][l] * betterminor(A, 0, l)
        return det

# Ввод матрицы
print('Введите количество строк матрицы и нажмите enter')
rowsA = int(input())
print('Вводите числа первой матрицы через пробел, для перехода на новую строку, нажмите enter')
for _ in range(rowsA):
    elem = [float(i) for i in input().split()]
    A.append(elem)


# Проверка матрицы на адекватность
for i in range(len(A)):
    if len(A[0]) != len(A[i]):
        sys.exit('у вас строки разной длины...')
if len(A)!= len(A[0]):
    sys.exit('матрица должна быть квадратной...')
if determinant(A) == 0:
    sys.exit('у такой матрицы нет обратной...')

# Собственно само нахождение обратной матрицы
AT = transpose(A)
for i in range(len(A)):
    rowB = []
    for j in range(len(A)):
        rowB.append(betterminor(AT, i, j)/determinant(A))
    B.append(rowB)

# Выравниваем и выводим
Bmax = 0
for row in B:
        for value in row:
            if len(str(value)) > Bmax:
                Bmax = len(str(value))
print("Обратная матрица:")
for _ in range(len(A)):
    for  in range(len(A)):
        print(str(B[_][]).ljust(Bmax+1), end='')
    print()
