#Проверка Унитарности и Самосопряжённости

import copy
import sys
A = []
B = []
print('Введите количество строк матрицы и нажмите enter')
rowsA = int(input())
print('Вводите числа матрицы через пробел, для перехода на новую строку, нажмите enter')
for _ in range(rowsA):
    elem = [float(i) for i in input().split()]
    A.append(elem)
A1 = copy.deepcopy(A)

# Проверка матрицы на адекватность
for i in range(len(A)):
    if len(A[0]) != len(A[i]):
        sys.exit('у вас строки разной длины...')
if len(A)!= len(A[0]):
    sys.exit('матрица должна быть квадратной...')

# Транспонирование маттрицы
def transpose(A):
    for i in range(len(A)):
        for j in range(i, len(A)):
            A[i][j], A[j][i] = A[j][i], A[i][j]
    return A

C = transpose(A1)

# Нахождение минора
def minor(A, i, j):
    min = copy.deepcopy(A)
    for l in range(len(min)):
        del(min[l][j])
    del(min[i])
    return min

# Превращение минора в алегбраическое дополнение
def betterminor(A, i, j):
    min = minor(A, i, j)
    bettermin = determinant(min)*((-1)**(i+j))
    return bettermin

# Нахождение детерминанта
def determinant(A):
    if len(A) == 1:
        return A[0][0]
    else:
        det = 0
        for l in range(len(A)):
            det += A[0][l] * betterminor(A, 0, l)
        return det

# Нахождение обратной
def obratnaya(A):
    if determinant(A) != 0:
        for i in range(len(A)):
            string = []
            for j in range(len(A)):
                string.append(betterminor(C, i, j)/determinant(A))
            B.append(string)
    return B

# Проверка условия унитарности
if C == obratnaya(A):
    print('унитарная')
else:
    print('неунитарная')

# Проверка самосопряжённости
if A == C:
    print('самосопряжённая')
else:
    print('несамосопряжённая')
